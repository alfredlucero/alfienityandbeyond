ANGULARJSBOOKNOTES

PROFESSIONAL ANGULARJS:

Chapter 1: Getting Ready
	- Batarang AngularJS extension on Google Chrome to monitor the model
	- installing node.js, npm install connect // to create a simple web server and pull all files required for the Connect module
	i.e.

	var connect = require('connect');
	connect.createServer(
		connect.static('../angularjs'); // serves up files in this folder and in same level as Node.js installation folder
	).listen(5000); // listen to requests on port 5000
	- has great support for unit testing with Karma test runner and Jasmine test framework
	i.e. npm install -g karma
	- extras such as angular-touch.js (touchscreen event support), angular-animate.js (animations when content changes), angular-mocks.js (mock objects for unit testing), angular-route.js (URL routing), angular-sanitize.js (provides escaping for dangerous content), angular-locale-fr-fr.js(localization for French)
	- Bootstrap CSS framework to help wtih creating clear content layouts without having to define and redefine custom CSS styles
	- LiveReload monitors the files in a folder and automatically reloads the browser when a change is detected -> look up another like this
	- uses Deployd, cross-platform tool for modeling APIs for web applications that is built on top of Node.js and MongoDB, which allows it to store data as JSON

	i.e. 
	<!DOCTYPE html>
	<html ng-app>
	<head>
		<title>First Test</title>
		<script src="angular.js"></script>
		<link href="bootstrap.css" rel="stylesheet" />
		<link href="bootstrap-theme.css" rel=stylesheet" />
	</head>
	<body>
		<div class="btn btn-default"> {{"AngularJS"}}</div>
		<div class="btn btn-success">Boostrap</div>
	</body>
	-> run: node server.js from the Node.js installation directory
	http://localhost:5000/test.html

	Chapter 2: Your First AngularJS App
	- add a script to import angular.js file, create AngularJS module, and apply an attribute to the html element
		-> apps are formed from one or more modules that are created by calling the angular.module method; takes in the name of the module and an array of other modules that are going to be needed
	i.e.
		<html ng-app="todoApp">
		...
		<script src="angular.js"></script>
		...
		var todoApp = angular.module("todoApp", []);
	- works by extending HTML by adding new elements, attributes, classes, and special comments -> dynamically compiles the HTML in a document in order to locate and process these additions and create an application
		-> evaluates HTML elements when the browser has loaded the content and uses standard DOM API and JavaScript to add and remove elements, set up event handlers, etc.
	- ng-app specifies that the html element contains a module that should be compiled and processed by AngularJS and if mixed with other technologies such as jQuery, can narrow the boundaries of AngularJS app by applying ng-app to an element within the document
	- Model-View-Controller pattern: data(the model), logic that operates on the data(the controller), logic that displays the data(the views)
	i.e.
		var model = {
			user: "Alfred",
			items: [
				{ action: "Buy Flowers", done: false },
				{ action: "Get Shoes", done: false },
				{ action: "Collect Tickets", done: true },
				{ action: "Call Joe", done: false }
			]
		}; // can include logic required to create, load, store, and modify data objects and is often at the server
	- controller defines the business logic required to support a view; storing or retrieving data is part of the model; formatting the data to display to the user is part of the view
		-> responds to user interaction, updating data in the model and providing view with data it requires
		-> created by calling the controller method on the Module object returned by calling angular.module; args are the name and a function that will be invoked to define the controller functionality
		i.e.
		todoApp.controller("ToDoCtrl", function($scope) {
			$scope.todo = model; // giving app access to entire model in views
		});
		...
		<body ng-controller="ToDoCtrl"> // convention is <Name>Ctrl
		...
		// $ represent built-in features or service, self-contained component that provides features to multiple controller
		-> $scope is used to expose data and functionality to views
		i.e. $scope.todo = model;
		...
		<body ng-controller="ToDoCtrl"> // specifies the region of the HTML document that the controller will be responsible for
	- views are generated by combining data the controller provides with annotated HTML elements that produce content for the browser to display -> data binding to populate HTML document with the model data
	i.e.
	<h1>
		{{todo.user}}'s To Do List
		<span class="label label-default">{{todo.items.length}}</span>
	</h1>
	...
	<tr ng-repeat="item in todo.items">
		<td>{{item.action}}</td>
		<td>{{item.done}}</td>
	</tr>
		-> double-brace characters to denote a data binding expression, content is evaluated as JavaScript that is limited to data and functions assigned to the scope by the controller
		-> compiles HTML, sees ng-controller, invokes ToDoCtrl to set scope that will be used to create view, as each data/model binding expresssion is encounter it looks up specified value on the $scope object and inserts value into HTML document
	- expressions are also used with directives that tell AngularJS how you want the content to be processed such as ng-repeat that generates the element it is applied to and its contents for each object in a collection
	i.e. generate tr and td elements it contains for each of the objects in todo.items array and assign each object in array to item variable
		<tr ng-repeat="item in todo.items">
			<td>{{item.action}}</td><td>{{item.done}}</td>
		</tr>
		// <name> in <collection>
		-> one-way bindings where values are taken from the model and used to populate elements in a template i.e. Handlebars template package with jQuery that provides data binding and useful for generating HTML content from data objects
	- provides two-way binding where the model is used to generate elements and changes in the element cause corresponding changes in the model
	i.e.
		<tr ng-repeat="item in todo.items">
			<td>{{item.action}}</td>
			<td><input type="checkbox" ng-model="item.done" /></td>
			<td>{{item.done}}</td>
		</tr>
		-> ng-model creates a two-way binding between the value of the input element and the done property of corresponding data object
		-> bindings are dynamic and two-way bindings updates the model which in turn updates other elements that have related data bindings
	- controllers define behaviors on the scope that are functions that operate on the data in the model to implement the business logic in the application -> support a view to display data to the user and to update the model based on user interactions
	i.e.
	todoApp.controller("ToDoCtrl", function($scope) {
		$scope.todo = model;

		$scope.incompleteCount = function() {
			var count = 0;
			angular.forEach($scope.todo.items, function(item) {
				if (!item.done) { count++; }
			}); // angular.forEach to enumerate contents of data array

			return count;
		}
	});
	...
	<span class="label label-default" ng-hide="incompleteCount() == 0">
		{{incompleteCount()}}
	</span>
	...
	<tbody>
		<tr ng-repeat="item in todo.items">
			<td>{{item.action}}</td>
			<td><input type="checkbox" ng-model="item.done" /></td>
		</tr>
	</tbody>
		-> name of the property to attach the function to the $scope object is used as the behavior name
		-> ng-hide directive will hide teh element it is applied to and its content elements if the expression that is assigned as the attribute value evaluates to true
		-> ng-class directive to give element a certain class based on a behavior function // combining behaviors and directives to respond to user interaction
		i.e.
		$scope.warningLevel = function() {
			return $scope.incompleteCount() < 3 ? "label-success" : "label-warning";
		}
		...
		<span class="label label-default" ng-class="warningLevel()" ng-hide="incompleteCount() == 0">
		i.e. 
		$scope.addNewItem = function(actionText) {
			$scope.todo.items.push({ action: actionText, done: false});
		}
		...
		<input class="form-control" ng-model="actionText" />
		<span class="input-group-btn">
			<button class="btn btn-default" ng-click="addNewItem(actionText">Add</button>
		</span>
		-> ng-model with form elements; will dynamically create the property for me within the scope of the controller to handle user input
		-> ng-click sets up a handler on click event that passes the dynamic actionText property as the argument
		-> filtering can be applied to any part of the data model; filter selects objects based on the criteria it is configured with whereas orderBy sorts the data items 
		i.e.
		<tr ng-repeat="item in todo.items | filter: {done: false} | orderBy:'action'">
			<td>{{item.action}}</td>
			<td><input type="checkbox" ng-model="item.done" /></td>
		</tr>
		i.e.
		todoApp.filter("checkedItems", function() {
			return function (items, showComplete) {
				var resultArr = [];
				angular.forEach(items, function (item) {
					if (item.done == false || showComplete == true) {
						resultArr.push(item);
					}
				});
				return resultArr;
			}
		}); // filter factory which returns a function that is use to filter a set of data objects
		...
		<tr ng-repeat="item in todo.items | checkedItems:showComplete | orderBy:'action'">
			<td>{{item.action}}</td>
			<td><input type="checkbox" ng-model="item.done" /></td>
		</tr>
		...
		<div class="checkbox-inline">
			<label><input type="checkbox" ng-model="showComplete">Show Complete</label>
		</div>
		- making an Ajax call for JSON data in todo.html
		i.e.
		var model = {
			user: "Adam"
		};

		todoApp.run(function($http) { // $http service object for making Ajax calls
			$http.get("todo.json").success(function(data) { // HTTP GET request to server for todo.json file
				model.items = data;
			});
		}); // using arguments to tell AngularJS what features you require is part of an approach known as dependency injection
		// result from the get method is a promise, an object used to represent work that will complete in the future, success when request to the server has completed and JSON data retrieved
	
	Chapter 3: Putting AngularJS in Context
		- goal is to bring tools and capabilities available for server-side development to the web client and in doing so, make it easier to develop, test, and maintain rich and complex web applicaitons
			-> extend HTML, custom markup, Model-View-Controller pattern
			-> lots of work to compile HTML elements, data bindings evaluated, directives executed, etc.; dependent on quality of browser and processing capability of device
		- two types of web application: round-trip and single-page
		- round-trip model: UI led the browser to request and receive a compleley new HTML document, rendering engine for HTML content, application logic and data resides on the server, series of stateless HTTP requests
			-> require little from browser with widest possible client support
			-> waiting for next HTML document request and load, server-side infrastructure to process and manage application state, bandwidth for self-contained HTML doc
		- single-page applications: an initial HTML document is sent to browser but UI lead to Ajax requests for small fragments of HTML or data inserted into the existing set of elements being displayed to the user; initial HTML document is never reloaded or replaced, continue to interact with existing HTML while Ajax requests are performed asynchronously
		- jQuery is about explicitly manipulating the browser's Document Object Model to create an application; AngularJS is to coopt the browser into being the foundation for application development
			-> hard to write large applications and unit test with jQuery but for low-complexity web apps and enhancing HTML generated by round-trip web apps where user interactions cause a new HTML document to be loaded
			-> AngularJS contains cut-down version of jQuery called jqLite that builds on the core functionality of jQuery to write custom directives; for more complex single-page web apps
			-> up-front investment in development time before you see results with AngularJS
		- MVC (model, view, controller) for separation of concerns; client-side web development means separating the data, the logic that operates on the data, and the HTML elements used to display the data
		i.e.
		Browser window ->user interaction-> controller -> model (persistence through a RESTful web service) -> controller -> view -> DOM -> browser window
			-> client-side MVC framework takes on some of complexity of server-side MVC framework and allows for more client support with less server capacity
		- models contain the data that users work with; two broad types: view models which represent data passed from controller to the view and domain models which contain data in a business domain along with operations, transformations, and rules for creating, storing, and manipulating the data
			-> effectively push logic to server side and invoke via a RESTful web service because there is little support for data persistence within the browser and easier to get data required over Ajax
			-> contain domain data, logic for creating, managing, and modifying the domain data, clean API to expose model data and operations on it
			-> should not contain logic that transforms the model based on user interaction = controller's job
			-> should not contain logic for displaying data to the user = view's job
			-> best domain models contain logic for getting and storing data persistently and for create, read, update, and delete operations known as CRUD, logic for calling RESTful web services to invoke server-side database operations
		- controllers act as conduits between the data model and views in adding business domain logic known as behaviors to scopes
			-> can create view data in response to user interaction and synthesizing some aspect of the domain model data
		- views are defined using HTML elements that are enhanced and that generate HTML by use of data bindings and directives
		- server contains persistent store/database and contains the logic for managing it; client logic is responsible for getting the data to and from the server
			-> passing data between client and server through Asynchronous JavaScript and XML (Ajax) requests to call server-side code, getting the server to send JSON and making changes to data using HTML forms
			-> REST is a style of API, JSON services are RESTful: operation is being requested through combination of the HTTP method and the URL
			-> GET retrieves data object specified by the URL
			-> PUT updates the data object specified by the URL
			-> POST creates a new data object, typically using form data values as the data fields // double duty as updating an object if one exists and creating one if not
		- problems with putting logic in the wrong places
			-> three common problems in putting business logic in views rather than controller; putting dommain logic in controllers rather than model; putting data store logic in the client model when using a RESTful service
			-> view logic should prepare data only for display and never modify the model
			-> controller logic should never directly create, update, or delete data from the model
			-> client should never directly access the data store
			-> DELETE deletes the data object specified by the URL
	Chapter 4: HTML and Boostrap CSS Primer
		- void elements that may not contain content, self-closing written without a separate end tag
		i.e.
		<input class="form-control" />
		- browser maintains a live model of the HTML document represented by JavaScript objects and when AngularJS modifies these objects, the browser updates the content it displays to reflect the modifications
		- Cascading Style Sheets consists of a comprehensive set of properties that can be used to configure every aspect of an element's appearance and a set of selectors that allow  properties to be appliedthose
			-> Twitter Bootstap classes applied to elements to style them consistently and some JS code that performs additional enhancements
			-> row class to a div element has the effect of setting up the grid layout for the content that the div element contains, defines 12 columns
			-> <meta name="viewport" content="width=device-width, initial-scale=1">
			-> when the width of the screen is less than the class supports, the cells in the grid row are stacked vertically rather than horizontally
	Chapter 5: JavaScript Primer
		- promise represents an asynchronous task such as an Ajax request
		- angular.isString, angular.uppercase, angular.lowercase, angular.isFunction, angular.toJson, angular.fromJson
		- dynamically typed language means you don't have to declare the data type of the parameters when you define the function, number of arguments you provide doesn't need to match the number of parameters in the function (undefined for the rest) -> can't create two functions with the same name and different parameters and expect JavaScript to differentiate between them based on the arguments you provide when invoking the function - polymorphism
			-> define two functions with the same name, the second definition replaces the first; closest you can come to polymorphism is to define a single function to act differently based on the number and the types of the arguments; awkward API and best avoided

			
