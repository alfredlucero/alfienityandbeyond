MASTERING C++:

CHEAT SHEET:
	strongly-typed language, case-sensitive
	short-circuit evaluation of operations, block scope

	VARIABLE TYPES
		char, bool, int, float, double, void
		int x = 0; OR int x (0); OR int x {0}; to initialize variables

		type deduction:
			use auto to let compiler figure out what the type of variable it is automatically by the initializer
				int foo = 0; -> auto bar = foo;
			can use type deduction with decltype
			// use to increase code readability and when type can't be obtained by other means
		type casting: sizeof returns number of bytes
			(new_type) expression
			new_type (expression)
				older versions:
				dynamic_cast <new_type> (expression) // pointers and references to classes
				static_cast, reinterpret_cast, const_cast
			i = (int) f; OR i = int (f);


	HEADER FILES
		#include <string>
		#include <cstring> // strcpy, strlen, strcmp, strcat
		#include <iostream> // cout/cin
		#include <fstream> // read/write files
		#include <iomanip> // advanced manipulator usage in streams
		#include <stdlib.h> // for general ops like system("PAUSE");
		#include <math>
		#include <cctype>

		Preprocessor definitions:
		#define identifier replacement
			i.e. #define PI 3.14159
		Preprocessor directives:
			lines included in the code preceded by a hash sign, examined before actual compilation and resolves all these directives before any code is actually generated by regular statements
			i.e. #ifdef, #define, #endif, #ifndef, #error, #include


	NAMESPACE: using namespace std;
		allows for elements in standard library to called in unqualified manner without std::cout
		allows us to group named entities that otherwise would have global scope into narrower scopes, giving them namespace scope and useful in avoiding name collisions
			i.e. namespace identifier
				{
					named_entities
				}
				qualified: identifier::named_entities
			using keyword/ using namespace introduces name into the current declarative region (such as a block), thus avoiding the need to qualify the name

		static storage: for variables with global or namespace scope allocated for the entire duration of the program, automatically initialized to zeroes
		automatic storage: for local variables within a block, left uninitialized if not explicitly initialized already

	I/O:
		cin, cout, cerr, clog
			use endl to flush the stream's buffer so output is requestedd to be physically written to the device if it wasn't already -> \n otherwise
			cout << str << endl;
			cin >> a >> b;
				considers whitespaces as terminating the value being extracted
				can use getline(cin, mystr);
		stringstream: #include <sstream>
			useful to extract numerical values from string
			i.e. 1)
			string str("1738");
			int value;
			stringstream(str) >> value;
			i.e. 2)
			string str;
			float price = 0;
			cout << "Enter price: ";
			getline(cin, str);
			stringstream(str) >> price;
		FILES:
			ofstream // write on files
			ifstream // read from files
			fstream // to both read and write from/to files
			i.e. open/close

	STRINGS: #include <string> (compound type)
		stirng mystr = "Example string";

	POINTERS:
		address-of operator (&)
			i.e.
				foo = &myvar;
		dereference operator (*): access variable they point to directly
		i.e. standard initializing
			int *ptr; // define pointer
			ptr = &var; // ptr set to address of var
			var2 = *ptr; // set var2 to value of var1
		i.e. array reference
			int myarray[20];
			int * mypointer = myarray;
			myarray[5] = 0; == *(a+5) = 0;
		i.e. const pointers: can't modify value it points to
			const int * p = &y;
			x = *p; // OK to read
			*p = x; // can't modify p
			const int * const p4 = &x; // const pointer to const int
			const char * foo = "hello"; // string literals -> access by foo[4] or *(foo+4)
		void pointers point to a value that has no type, data pointed to by them cannot be directly dereferenced
		nullptr or int * ptr = 0;
		pointers to functions:
			i.e.
			int operation (int x, int y, int (*functocall)(int,int))
			{
				int g;
				g = (*functocall)(x,y);
				return (g);
			}
			...
			m = operation (7, 5, addition);
			int (*minus)(int, int) = subtraction;

	DYNAMIC MEMORY:
		memory needs of a program determined during runtime such as when it depends on user input, allocated from memory heap
			exception of bad_alloc thrown when allocation fails due to limited resources
			nothrow (failure can be detected by checkign if foo is a null pointer)
				i.e.
					int * foo;
					foo = new (nothrow) int [5];
					if (foo == nullptr) 
						// error assigning memory
		
		pointer = new type
		pointer = new type [number_of_elements]
			i.e.
				 int * foo;
				 foo = new int[3];

		delete pointer;
		delete[] pointer; // for array of elements

	DATA STRUCTURES:
		group of data elements grouped together under one name, can be nested
		struct type_name {
			member_type1 member_name1;
			....
		} object_names;
		i.e.
			struct product {
				int weight;
				double price;
			} apple, banana, melon;
			apple.weight
			product * applePtr = &apple;
			applePtr->price // (*applePtr).price

			a.b // member b of objecft a
			a->b // member b of object pointed to by a
			*a.b // value pointed to by member mb of object a

		type aliases (typedef / using)
			creates synonyms of different types
			typedef existing_type new_type_name
			i.e.
				typedef char * pChar;
				pChar ptc2;
			using WORD = unsigned int;

		Unions allow one portion of memory to be accessed as different data types, can be anonymous
			union type_name {
				member_type1 member_name1;
			} object_names;
			i.e.
				union mytypes_t {
					char c;
					int i;
					float f;
				} mytypes; // all member elements occupy the same physical space in memory, size is of largest member element, possible alignment/ordering issues
				// cannot be used to store two different values simultaneously

		Enums are defined with a set of custom identifiers as possible values, implicitly convertible to int (starts from 0 value onwards)
		enum type_name {
			value1,
			value2,
			...
		} object_names;
			i.e. enum colors_t {red, blue, black};
			enum class EyeColor : char {blue, green, brown}; // determine size of type, not implicitly convertible to int


	IF ELSE:
		if(<condition>) { <statement1>; }
		else { <statement2>; }
	FOR:
		for(<initialize>; <condition>; <update>)
		{ <statement>; }
		range-based: iterates over all elements in the range
			i.e.
				for (char c: str)
					std::cout << "[" << c << "]";
	WHILE:
		while(<condition>) { <statement>; }
	DO-WHILE:
		do { <statement>; }
		while(<condition>);
	SWITCH:
		switch(<expression>) {
			case <constant>:
				<statement sequence 1>;
				break;
			default:
				<statement sequence n>;
				break;
		}

	EXCEPTIONS:
		#include <exception>
			provides a base class specifically designed to declare objects to be thrown as exceptions
		provide way to react to exceptional circumstances like runtime errors in programs by transferring control to special functions called handlers
		i.e.
		try
		{
			throw 20;
		}
		catch(int e)
		{
			cout << "Exception occurred " << e << endl;
		}

	ARRAYS:
		series of elements of same type placed in contiguous memory locations that can be individually referenced by adding an index to a unique identifier
		type name [elements]; // elements should be constant expression, static memory size determined at compile time
		i.e. int myArray[5];
			 myArray[2] = var;
			 int baz [5] = { }; // initialized to zeroes
			 int foo[] = {10,20,30} === int foo[] {10,20,30};
			 name[index] // access
			 int jimmy[HEIGHT][WIDTH]; // multidimensional
			 int jimmy[HEIGHT * WIDTH]; // pseudo-multidimensional
			 for (n = 0; n < HEIGHT; n++)
			 	for (m = 0; m < WIDTH; m++)
			 		jimmy[n][m] = (n+1)*(m+1);
			 vs.
			 for (n = 0; n < HEIGHT; n++)
			 	for (m = 0; m < WIDTH; m++)
			 		jimmy[n*WIDTH + m] = (n+1)*(m+1);
			 passing as parameters: 
			 	void procedure(int arg[])
			 	void procedure(int myarray[][3][4]) -> passed by reference
			 stl <array>:
			 	array<int,3> myarray {10,20,30};
			 	myarray.size();

		character sequence: C-strings
			i.e. char myword[] = {'H', 'e', 'l', 'l', 'o', '\0'}; == char myword[] = "Hello"; // string literals terminated with null character
			// strings have dynamic size determined during runtime, size of arrays determined on compilation
			i.e. conversion between c-string and string
			char myntcs[] = "some text";
			string mystring = myntcs; // convert c-string to string
			cout << mystring;  // print as library string
			cout < mystring.c_str(); // print as cstring



	I/O OPERATORS:
		cin >> var1, var2, var3;
		cout << "STRING: " << var1 << endl;

	FILE I/O:
		fstream file;
		file.open("filename", <file mode constant>);
		// Reads and writes like cin and cout
		file >> var;
		file << "Text: " << var1 << endl;
		// Reading and writing binary data
		file.read(memory_block, size);
		file.write(memory_block, size);
		file.close();

	FUNCTIONS:
		<return_data_type> <function_name> (parameter list) { body of the function }
		parameter passing:
			call by value (small objects not altered by function, create copies)
				i.e. void duplicate (int a, int b)
			call by constant reference (large referenced objects not altered by function)
				i.e. string concatenate (const string& a, const string& b)
			call by reference (objects altered by function, avoid cost of copying)
				i.e. void duplicate (int& a, int& b)
		inline: informs the compiler that code generated by the function body shall be inserted at each point the function is called, instead of being invoked with a regular function call
		default values
		declaring functions
			prototypes // allows functions to be called before they are entirely defined
				i.e. void odd (int x);
				... // main()
				void odd (int x) 
				{
					if ((x%2) != 0)
						cout << "It is odd" << endl;
					else
						cout << "It is even" << endl;
				}
		recursion: functions have to be called by themselves
			i.e.
			long factorial (long a) 
			{
				if (a == 1)
					return 1;
				else if (a > 1)
					return a * factorial (a-1);
			}
		
		overloaded: when they have the same function name but have different number of parameters or any of their parameters are of a different type

		templates: generic types
		template <typename someType>
		SomeType sum (SomeType a, SomeType b)
		{
			return a + b;
		}
			i.e. x = sum<int>(10, 20);


	CLASSES:
		class <class_name>
		{
			public: // accessible from anywhere the object is visible
				// method_prototypes
			protected: // from within other members of the same class and derived classes
				// method_prototypes
			private: // access specifiers, accessible from within other members of the same class
				// method_prototypes
				// data_attributes
		};
		i.e.
			class Rectangle {
				int width, height; // private if not specified
				public:
					Rectangle (int, int)
					int area (void);
			} rect;
			void Rectangle::Rectangle(int x, int y) {
				width = x;
				height = y;
			}
			Rectangle rect (3,4);
			myarea = rect.area();
		constructors className() // never return values, initialize the object
			default constructor called without empty parentheses such as Rectangle rectb; OR Rectangle rectb{};
			member initialization list
			i.e.
				Cylinder(double r, double h) : base(r), height(h) {}; // Circle base(double r) within Cylinder
		destructors ~className() called when object goes out of scope or subject to a delete, called on all data members
		copy constructor for declaration
		copy assignment operator: operator= called when objects on both sides of assignment already constructed

		overloading operators (operator=, assignment)
			i.e. operator+
			CVector operator+(const CVector& lhs, const CVector& rhs) {
				CVector temp;
				temp.x = lhs.x + rhs.x;
				temp.y = lhs.y + rhs.y;
				return temp;
			}

		keyword this: represents a pointer to the object whose member function is being execute, used within a class's member function to refer to the object itself

		static data members ("class variable"): one common variable for all the objects of that same class, sharing the same value
			i.e. initialized outside class such as static int n; // within class Dummy
				int Dummy::n=0; // initialized outside

		const MyClass myobject; // access to its data members from outside the class is restricted to read-only
		int get() const {return x;} // can't modify non-static members nor call other non-const member functions, can't modify state of the object
			const objects are limited to access only member functions marked as const

		i.e.
		#ifndef IntCell_H
		#define IntCell_H
		class IntCell {
			public:
				IntCell(int initialValue = 0); // constructor
				IntCell(const IntCell & rhs); // copy constructor
				~IntCell(); // destructor
				const IntCell & operator=(const IntCell & rhs); // copy assignment operator
				int read() const;
				void write(int x);
			private:
				int storedValue;
		};
		#endif

		// IntCell.cpp
		#include "IntCell.h"
		IntCell::IntCell(int initialValue)
			: storedValue(initialValue) {}
		IntCell::~IntCell() {}
		IntCell::IntCell(const IntCell & rhs) : storedValue(rhs.storedValue) {}
		const IntCell & IntCell::operator=(const IntCell & rhs) {
			if (this != &rhs) // alias test
				storedValue = rhs.storedValue;
			return *this;
		}
		int IntCell::read() const {
			return storedValue;
		}
		void IntCell::write(int x) {
			storedValue = x;
		}

		// main.cpp
		#include <iostream>
		#include "IntCell.h"
		using namespace std;

		int main() {
			IntCell *m;
			m = new IntCell(0);
			m->write(5);
			cout << "Cell contents: " << m->read() << endl;
			delete m;
			return 0;
		}

	FRIENDS:
		can access private and protected members of a class through non-member function/different class
		i.e.
			friend Rectangle duplicate (const Rectangle&);
			foo = duplicate(bar);

	TEMPLATES:
	i.e. generic template
		template <class T>
		class mypair {
			T a, b;
			public:
				mypair(T first, T second) {
					a = first; b = second;
				}
				T getmax();
		};
		template <class T>
		T mypair<T>::getmax() {

		} // mypair<int> myobject(100, 50);
	i.e.
	template <typename Object>
	class MemoryCell
	{
		public:
			MemoryCell( const Object & initialValue = Object() )
			: storedValue(initialValue) {}
			const Object & read() const { return storedValue; }
			void write (const Object& x) { storedValue = x; }
		private:
			Object storedValue;
	};
	i.e. template specialization
		template <>
		class mycontainer <char> {
			char element;
			public:
				mycontainer(char arg) { element = arg; }
				char uppercase()
				{
					if ((element >= 'a') && (element <= 'z'))
					element += 'A' - 'a';
					return element;
				}
		};

	SPECIAL MEMBER FUNCTIONS:
		Default constructor: C::C();
			constructor called when objects of a class are declared but not initialized with any arguments
		Destructor: C::~C();
			called automatically at the end of the object's life in charge of releasing this memory
		Copy Constructor: C::C(const C&);
			implicitly defined otherwise but give shallow copy in which the pointer value is copied but not the content itself (both objects sharing a single entity and trying to delete the same block of memory -> crash)
			provides a deep copy(copy and original stored in different locations)
			i.e.
				MyClass foo;
				MyClass bar (foo);
				MyClass bar = foo;
		Copy Assignment: C& operator= (const C&);
			returns *this
			danger of shallow assignment for implicitly defined one leading to deleting the pointed object twice a nd memory leaks by not deleting the object pointed by the object before the assignment
			i.e. 
				Example5& operator= (const Example5& x) {
					delete ptr;
					ptr = new string(x.content());
					return * this;
				}
		Move Constructor: C::C (C&&);
			when an object is initialized on construction using an unnamed temporary
		Move Assignment: C& operator= (C&&);
			when an object is assigned the value of an unnamed temporary
			// return value optimization?


	ABSTRACT CLASSES: can't create instance of these
		virtual void functionName(parameters) = 0;

	INHERITANCE EXAMPLE:
		multiple inheritance
		class derived_class_name: public base_class_name { ... };
		when a class inherits another one, the members of the derived lass can access the protected members inherited from the base class, but not its private members
		a publicly derived class inherits access to every member of a base class except its constructor/destructor, assignment operator members, friends, private members
		constructors of a derived class calls the default constructor of its base classes or you must use the initialization list

		i.e. Simple inheritance
		class Polygon {
			public:
				void set_values(int a, int b) 
				{
					width = a; 
					height = b;
				}
				virtual int area() { return 0;}
			private:	
				int width, height;
		};

		class Rectangle : public Polygon {
			public:
				virtual int area() {
					return width * height;
				}
		};

		class Triangle : public Polygon {
			public:
				virtual int area() {
					return width * height / 2;
				}
		};


		POLYMORPHISM:
			a pointer to a derived class is type-compatible with a pointer to its base class
		i.e. use Polygon example above
			Polygon * poly1 = new Rectangle(4,5);
			Polygon * poly2 = new Triangle(5,6);
			poly1->set_values(4,5);
			poly2->set_values(5,6);
			cout << poly1->area() << poly2->area() << endl;
			delete poly1;
			delete poly2;

			VIRTUAL member is a member function that can be redefined in a derived class while preserving its calling properties through references
				allows a member of a derived class with the same name as one in the base class to be appropriately called from a pointer whose type is a pointer to the base class that is pointing to an

			ABSTRACT base classes are allowed to have virtual functions without definition (pure virtual functions) and cannot be used to instantiate objects
				i.e. virtual int area() = 0;

		i.e.
		#include <iostream>
		#include <cstring>

		class Employee {
			
			private: 
				char name[51];
				double wage;
			protected:
				double payOwed;
			public:
				Employee(char n[], double w) {
					strcpy(name, n);
					setWage(w);
					payOwed = 0;
				} // constructor

				virtual void pay(double hours) {
					payOwed += wage * hours;
				} 

				double amountToPay() {
					return payOwed;
				}

				void zero() {
					payOwed = 0;
				}

				virtual void print() {
					printf(...)
					....
				}

				void println() {
					print();
					printf("\n");
				}
		};

		class Salesperson: public Employee {
			private:
				double rate;
			public:
				Salesperson(char name[], double wage, double rate) : Employee(name, wage) {
					this->rate = rate;
				}

				void payForSale(double amount) {
					payOwed += amount * rate;
				}

				virtual void print() {
					printf(...);
					Employee::print();
					printf(...);
				}
		};

		int main() {
			Employee mickey("Mickey Mouse", 20);
			mickey.setWage(21);
			mickey.println();
			Salesperson* donald = new Salesperson("Donald Duck", 10, 0.15);
			donald->payForSale(100);
			donald->println();
			Employee* company[2];
			company[0] = &mickey;
			company[1] = donald;
			for (int i = 0; i < 2; i++) {
				company[i]->pay(10);
				company[i]->println();
			}
		}

	STRUCTS:
		struct <structure_name> {
			member_type member_name;
		} <object_name>;

	ACCESSING DATA STRUCTURES:
		// Accesss member variable from struct/class
		myStruct.membervar1 = var;
		// Call class method
		myClass.method1(args);
		//Pointer to Struct/Class
		myStructType *ptr;
		ptr = &myStruct;
		ptr->membervar1 = var;

	LINKED LISTS:
		struct Node {
			int x;
			Node *next;
		}
		int main() {
			Node *root;
			Node *conductor;
			root = new Node;
			root->next = nullptr;
			root->x = 5;
			conductor = root;
			if (conductor != nullptr) { 
				while (conductor->next != nullptr) // traverse the list to the last node
					conductor = conductor->next;
			}
			conductor->next = new Node; // Creates new node at end of list
			conductor = conductor->next;
			conductor->next = nullptr;
			conductor->x = 42;
		}
	
	STL (STANDARD TEMPLATE LIBRARY):
		i.e. vector<int> intVect;
				 vector< vector<int> > nestedVect;
		Containers to hold elements and manipulate them

		VECTORS: array with extended functionality
			#include <vector>
			i.e. 
				vector<string> names(20, "No name");
				vector<int> v(10);
				for(int i = 0; i < 10; i++) {
					v[i] = (i+1)*(i+1);
				}

				v.size(); // unsigned, returns number of elements
				v.empty(); // better practice to determine whether 0 elements or not
				v.push_back(value); // adds an element to the end of the vector
				v.resize(new_size); // make vector contain the required number of elements, extras will be deleted, new elements filled with zeroes
				v.clear(); // makes vector contain 0 elements

				multi-dimensional -> vector< vector<int> > matrix;
					i.e.
					vector< vector<int> > matrix(N, vector<int>(M, -1)); // NxM matrix filled with -1

				call vectors with & in functions to avoid copying it all by value -> i.e. const vector<int>& v

				PAIRS:
					pair of elements, have built-in operations to compare themselves (first-to-second element) -> easy to sort
					i.e.
					pair<string, pair<int,int> > P;
					string s = P.first;
					int x = P.second.first; // extracts first int
					int y - P.second.second; // extracts second int

				Iterators: most general way to access data in containers
					begin
					end -> points to first invalid object, following the last one
						// c.end() - c.begin() == c.size() or c.begin() == c.end() iff empty
						i.e. to reverse template fashion
						if (begin != end)
						{
							end--;
							if(begin != end) {
								while(true) {
									swap(*begin, *end)
									begin++;
									if (begin == end)
										break;
									end--;
									if (begin == end)
										break;
								}
							}
						i.e. constructing using begin and end
							vector<int> v;
							...
							vector<int> v2(v.begin(), v.end());
							i.e. constructing array with first half of v, ordered back-to-front
							vector<int> v2(v.rbegin()+(v.size()/2), v.rend());
						i.e. traverse vectors
						for(vector<int>::iterator it = v.begin(); it != v.end(); it++)
							*it++; // increment the value iterator is pointing to
						i.e. common iterator pitfall const reference
						void f(const vector<int>& v) {
							for(vector<int>const_iterator it = v.begin(); it != v.end(); it++)
								r += (*it)*(*it);
						}

						
					STL find() -> #include <algorithm>
						find(v.begin(), v.end(), 49) != v.end() // looks within interval for value and returns iterator pointing to first occurrence of the element or equivalent to v.end() if not found		
						i.e. get index by find(v.begin(), v.end(), 49) - v.begin();
							if (i < v.size()) {
								...
							}
					STL max_element/min_element
					i.e.
						int data[5] = { 1, 5, 2, 4, 3 };
						vector<int> X(data, data+5);
						int v1 = *max_element(X.begin(), X.end()); // returns value of max element in vector
						int v2 = min_element(X.begin(), X.end()) - X.begin(); // returns index of min element in vector
					STL sort
					i.e.
						vector<int> x;
						sort(x.begin(), x.end()); // sort in ascending order

					v.insert(1, 46); // insert value 42 after the first, shifts everything from index 1 to last one to the right
					v.erase(iterator); // single element of vector is deleted
						v.erase(begin iterator, end iterator); // interval erased from vector

					traverse macros: useful for all STL
					#define tr(container, it) \
						for(typeof(container.begin()) it = container.begin(); it != container.end(); it++)

						i.e. works for all stl
							tr(v, it) {
								r += (*it)*(*it);
							}

				SET:
					no duplicates, order doesn't matter, traverse through iterators
					add/remove, check whether elements are present in set -> O(log N) binary tree
					count of elements -> O(1)
					i.e.
						set<int> s;
						for(int i = 0; i <= 100; i++)
							s.insert(i);
						for(int j = 2; j <= 100; j += 2)
							s.erase(i);
					i.e. traversing
						for(set<int>iterator::it = s.begin(); it != s.end(); it++)
							r += *it;

					use find() member function to determine whether an element is present in set (also in multimap/set, hashmap/set for O(logN)), returns iterator to element found or end()
					i.e.
						if(s.find(17) != s.end())
							// found 17 in set
					use erase() member function to delete an element from set, insert() to add an element to set

					can be used to get rid of duplicates in vector and sort it
					i.e.
						set<int> s(v.begin(), v.end());
						vector<int> v2(s.begin(), s.end()); // v2 in ascending order and with duplicates removed

				MAP:
					contains pairs: <key, value>
					stored as red-black trees, sorted in ascending order while traversing these containers like sets
						don't change the key part
					i.e.
						map<string, int> M;
						M["Top"] = 1;
						int x = M["Top"];
						if (M.find("SRM") != M.end()) {
							M.erase("SRM");
						}
						it->second; to refer to value part of pair

				ALGORITHMS:
					min(a,b)/max(a,b)/swap(a,b)
					find(begin,end,element) // O(N) vs. ones for set and map O(logN)
					count(begin,end, element) // O(N)
					permutations
						i.e. check all permutations, make sure elements are sorted in container
						do {
							...
						} while (next_permutation(v.begin(), v.end()));
				SSTREAMS:
					istringstream is(s);
					vector<int> v;
					int temp;
					while (is >> temp) // read integer while possible and add it to vector
						v.push_back(temp);

				MACROS:
				 typedef vector<int> vi; 
				 typedef vector<vi> vvi; 
				 typedef pair<int,int> ii; 
				 #define sz(a) int((a).size()) 
				 #define pb push_back 
				 #defile all(c) (c).begin(),(c).end() 
				 #define tr(c,i) for(typeof((c).begin()) i = (c).begin(); i != (c).end(); i++) 
				 #define present(c,x) ((c).find(x) != (c).end()) 
				 #define cpresent(c,x) (find(all(c),x) != (c).end()) 

				copy(from_begin, from_end, to_begin);
				i.e.
					v1.resize(v1.size() + v2.size());
					copy(all(v2), v1.end() - v2.size()); // copy v2 elements right after v1 ones

				set_intersection/union/difference/symmetric_difference(begin1, end1, begin2, end2, begin_result);
				i.e. O(N1 + N2)
					vector<int> res = vector<int> (tmp.begin(), set_intersection(all(v1), all(v2), tmp.begin());


				int sum = accumulate(all(v), 0);
				OR
				long long sum = accumulate(all(v), (long long) 0);
				double product = accumulate(all(v), double(1), multiplies<double>());
				int r = inner_product(all(v1), v2.begin(), 0); 

				* all comparison is based on 'operator <' so implement it for objects to be stored in set/map

				v.reserve() // orders vector to allocate additional memory, vector will not enlarge on push_back() operations until the size specified by reserve() will be reached







